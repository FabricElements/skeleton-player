<script>
  /**
   * Fabric.skeletonPlayerMixin
   *
   * @polymerMixin
   * @override
   * @memberOf Fabric
   * @constructor
   */
  const skeletonPlayerMixin = (superclass) => class extends superclass {
    constructor() {
      super();
    }

    connectedCallback() {
      super.connectedCallback();

      this._actionListeners();
      this._playerListeners();
      // Listen for change event on the slider
      this.addEventListener('change', (e) => this.changeProgress(e));
    }

    static get properties() {
      return {
        type: {
          type: String,
          value: null,
        },
        src: {
          type: String,
          value: null,
        },
        playSwitch: {
          type: Boolean,
          value: false,
          observer: '_playSwitchObserver',
        },
        autoplay: {
          type: Boolean,
          value: false,
        },
        controls: {
          type: Boolean,
          value: false,
        },
        preload: {
          type: String,
          value: 'metadata',
        },
        loop: {
          type: Boolean,
          value: false,
        },
        muted: {
          type: Boolean,
          value: false,
        },
        playing: {
          type: Boolean,
          value: false,
        },
        paused: {
          type: Boolean,
          value: false,
        },
        ended: {
          type: Boolean,
          value: false,
        },
        timeOffset: {
          type: Number,
          value: 0,
        },
        percentagePlayed: {
          type: Number,
          value: 0,
        },
        duration: {
          type: Number,
          value: 0,
        },
        disabled: {
          type: Boolean,
          value: false,
        },
        error: {
          type: Boolean,
          value: false,
        },
        events: {
          type: Array,
          value: null,
          observer: '_eventsObserver',
        },
        finalEvents: {
          type: Object,
          value: null,
        },
        loaded: {
          type: Boolean,
          value: false,
        },
        progress: {
          type: Number,
          value: 0,
          reflectToAttribute: true,
          observer: '_progressObserver',
        },
        progressInt: {
          type: Number,
          value: 0,
          reflectToAttribute: true,
        },
        secondaryProgress: {
          type: Number,
          value: 0,
          reflectToAttribute: true,
        },
        immediateValue: {
          type: Number,
          value: 0,
          reflectToAttribute: true,
        },
        icon: {
          type: String,
          value: 'player:loop',
          observer: '_iconObserver',
        },
        timeTotal: {
          type: Number,
          value: 0,
        },
        timeLeft: {
          type: Number,
          value: 0,
        },
        timeCurrent: {
          type: Number,
          value: 0,
        },
        firstPlayAction: {
          type: Boolean,
          value: false,
        },
        jump: {
          type: Number,
          value: 0,
          observer: '_jumpObserver',
        },
      };
    }

    _playSwitchObserver(newValue, oldValue) {
      if (newValue === oldValue || !this.firstPlayAction) return;
      if (newValue) return this.play();
      return this.pause();
    }

    _actionListeners() {
      const action = this.shadowRoot.querySelector('#action');
      if (!action) return;
      action.addEventListener('tap', (e) => this.togglePlay(e));
    }

    _playerListeners() {
      const player = this.shadowRoot.querySelector('#player');
      if (!player) return;
      player.addEventListener('loadedmetadata', (e) => this._loadedMetadata(e));
      player.addEventListener('play', (e) => this._playEvent(e));
      player.addEventListener('playing', (e) => this._playing(e));
      player.addEventListener('pause', (e) => this._paused(e));
      player.addEventListener('timeupdate', (e) => this._progress(e));
      player.addEventListener('error', (e) => this._error(e));
      player.addEventListener('ended', (e) => this._ended(e));
    }

    _resetProperties() {
      this.disabled = false;
      this.error = false;
      this.paused = false;
      this.ended = false;
      this.playing = false;
    }

    _loadedMetadata() {
      this.loaded = true;
      const player = this.shadowRoot.querySelector('#player');
      this.duration = player.duration;
      this.timeLeft = player.duration;
      this.timeTotal = player.duration;

      this.icon = 'player:play-arrow';
    }

    _error() {
      this._resetProperties();
      this.error = true;
      this.disabled = true;
    }

    togglePlay() {
      if (this.playing) return this.pause();
      this.play();
    }

    play() {
      this.shadowRoot.querySelector('#player').play();
    }

    pause() {
      this.shadowRoot.querySelector('#player').pause();
    }

    _playEvent() {
      this.dispatchEvent(new CustomEvent('skeleton-player-state-change', {
        detail: 'play',
        bubbles: true,
        composed: true,
      }));
    }

    _playing() {
      this._resetProperties();
      const player = this.shadowRoot.querySelector('#player');
      this.played = player.played;
      this.playing = true;
      this.dispatchEvent(new CustomEvent('skeleton-player-state-change', {
        detail: 'playing',
        bubbles: true,
        composed: true,
      }));
      this.icon = 'player:pause';
      this.firstPlayAction = true;
    }

    _ended() {
      this._resetProperties();
      this.ended = true;
      this.dispatchEvent(new CustomEvent('skeleton-player-state-change', {
        detail: 'ended',
        bubbles: true,
        composed: true,
      }));
      this.icon = 'player:replay';
    }

    _progress() {
      const player = this.shadowRoot.querySelector('#player');
      this.progress = (player.currentTime / player.duration) * 100;
      this.timeLeft = player.duration - player.currentTime;
      this.timeTotal = player.duration;
      this.timeCurrent = player.currentTime;
      this._checkTimeEvents(player.currentTime);
    }

    _jumpObserver(time) {
      if (time < 0 || !time) return;
      const player = this.shadowRoot.querySelector('#player');
      player.currentTime = time;
    }

    _progressObserver(progress) {
      this.progressInt = Math.floor(progress);
    }

    _paused() {
      this._resetProperties();
      this.paused = true;
      this.icon = 'player:play-arrow';
      this.dispatchEvent(new CustomEvent('skeleton-player-state-change', {
        detail: 'paused',
        bubbles: true,
        composed: true,
      }));
    }

    changeProgress() {
      let position = this.immediateValue / 100;
      const player = this.shadowRoot.querySelector('#player');
      player.currentTime = this.duration * position;
      this._resetEventsBeforeNewTime();
    }

    _resetEventsBeforeNewTime() {
      const player = this.shadowRoot.querySelector('#player');
      let time = player.currentTime;
      time = Math.floor(time);

      if (!this.finalEvents) return;
      for (let event in this.finalEvents) {
        if (!event) return;
        if (this.finalEvents[event].time >= time) {
          this.finalEvents[event]['fired'] = false;
        }
      }
    }

    _eventsObserver(events) {
      if (!events) return;
      let baseEvents = [];
      for (let event in events) {
        if (!event) return;
        let eventBase = {
          event: events[event],
          time: event,
          fired: false,
        };
        baseEvents.push(eventBase);
      }
      if (baseEvents[0]) this.finalEvents = baseEvents;
    }

    _checkTimeEvents(time) {
      if (!this.finalEvents) return;
      time = Math.floor(time);
      const events = this.finalEvents;

      for (let event in events) {
        if (!events[event]['fired'] && time >= events[event]['time']) {
          this.finalEvents[event]['fired'] = true;
          const finalEvent = events[event]['event'];
          this.dispatchEvent(new CustomEvent('skeleton-player-event', {
            detail: finalEvent,
            bubbles: true,
            composed: true,
          }));
        }
      }
    }

    _iconObserver(icon) {
      const action = this.shadowRoot.querySelector('#action');
      if (!action) return;
      action.icon = icon;
    }

    _secToMin(seconds) {
      if (seconds === 0) return '';
      let minutes = Math.floor(seconds / 60);
      let secondsToCalc = Math.floor(seconds % 60) + '';
      return minutes + ':' + (
        secondsToCalc.length < 2 ? '0' + secondsToCalc : secondsToCalc
      );
    }
  };
  window.Fabric = window.Fabric || {};
  window.Fabric.skeletonPlayerMixin = skeletonPlayerMixin;
</script>
